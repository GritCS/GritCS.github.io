<!DOCTYPE html>
<html lang="zh-Hans">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.15.3/css/all.min.css" integrity="sha256-2H3fkXt6FEmrReK448mDVGKb3WW2ZZw35gI7vqHOE4Y=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/animate.css@3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"example.com","root":"/","images":"/images","scheme":"Gemini","version":"8.6.1","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":false,"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"بحث...","empty":"We didn't find any results for the search: ${query}","hits_time":"${hits} results found in ${time} ms","hits":"${hits} results found"}}</script><script src="/js/config.js"></script>
<meta name="description" content="记录点滴成长">
<meta property="og:type" content="website">
<meta property="og:title" content="Think World">
<meta property="og:url" content="http://example.com/page/4/index.html">
<meta property="og:site_name" content="Think World">
<meta property="og:description" content="记录点滴成长">
<meta property="og:locale">
<meta property="article:author" content="Sherry Wang">
<meta property="article:tag" content="computer vision, DeepLearning ,MachineLearning">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="http://example.com/page/4/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":true,"isPost":false,"lang":"zh-Hans","comments":"","permalink":"","path":"page/4/index.html","title":""}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>Think World</title>
  




  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="تشغيل شريط التصفح" role="button">
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">Think World</h1>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">从个人成长角度来说，从经历中学点什么总是最重要的</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>







</div>
        
  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          المحتويات
        </li>
        <li class="sidebar-nav-overview">
          عام
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-overview">
            <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Sherry Wang"
      src="/images/aa.webp">
  <p class="site-author-name" itemprop="name">Sherry Wang</p>
  <div class="site-description" itemprop="description">记录点滴成长</div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives">
          <span class="site-state-item-count">60</span>
          <span class="site-state-item-name">المقالات</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
        <span class="site-state-item-count">11</span>
        <span class="site-state-item-name">التصنيفات</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
        <span class="site-state-item-count">20</span>
        <span class="site-state-item-name">الوسوم</span></a>
      </div>
  </nav>
</div>



          </div>
        </div>
      </div>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="back-to-top" role="button" aria-label="Back to top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner index posts-expand">

    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/03/16/%E6%9C%BA%E8%AF%95%E6%A8%A1%E6%9D%BF/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/aa.webp">
      <meta itemprop="name" content="Sherry Wang">
      <meta itemprop="description" content="记录点滴成长">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Think World">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/03/16/%E6%9C%BA%E8%AF%95%E6%A8%A1%E6%9D%BF/" class="post-title-link" itemprop="url">机试模板</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">نُشر في</span>

      <time title="أُنشأ: 2021-03-16 20:27:24" itemprop="dateCreated datePublished" datetime="2021-03-16T20:27:24+08:00">2021-03-16</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">عُدل في</span>
        <time title="عُدل: 2021-03-22 02:05:52" itemprop="dateModified" datetime="2021-03-22T02:05:52+08:00">2021-03-22</time>
      </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="线性表"><a href="#线性表" class="headerlink" title="线性表"></a>线性表</h1><p>总结写在前：</p>
<p>线性表</p>
<p>​    二分，归并</p>
<h2 id="题目1："><a href="#题目1：" class="headerlink" title="题目1："></a>题目1：</h2><blockquote>
<p>​    给定两个已经排序好的数组，找到两者所有元素中第k大的元素</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>



      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/03/16/STL%E5%87%BD%E6%95%B0%E6%A8%A1%E6%9D%BF/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/aa.webp">
      <meta itemprop="name" content="Sherry Wang">
      <meta itemprop="description" content="记录点滴成长">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Think World">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/03/16/STL%E5%87%BD%E6%95%B0%E6%A8%A1%E6%9D%BF/" class="post-title-link" itemprop="url">STL函数模板</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">نُشر في</span>

      <time title="أُنشأ: 2021-03-16 20:26:45" itemprop="dateCreated datePublished" datetime="2021-03-16T20:26:45+08:00">2021-03-16</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">عُدل في</span>
        <time title="عُدل: 2021-07-25 08:54:52" itemprop="dateModified" datetime="2021-07-25T08:54:52+08:00">2021-07-25</time>
      </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="STL常见函数模板"><a href="#STL常见函数模板" class="headerlink" title="STL常见函数模板"></a>STL常见函数模板</h1><h2 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h2><p><strong>利用二分查找的方法在一个排好序的数组中进行查找</strong></p>
<h3 id="‘upper-bound’-amp-amp-‘lower-bound’"><a href="#‘upper-bound’-amp-amp-‘lower-bound’" class="headerlink" title="‘upper_bound’ &amp;&amp; ‘lower_bound’"></a>‘upper_bound’ &amp;&amp; ‘lower_bound’</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">upper_bound</span>(begin,end,num);</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">对于从小到大的排序数组，upper_bound()从数组的begin位置到end-1位置二分查找第一个大于num的数字，如果找到，则返回该数组的迭代器;反之，返回end迭代器</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">对于从大到小的排序数组，upper_bound()从数组的begin位置到end-1位置二分查找第一个小于num的数字，如果找到，则返回该数组的迭代器;反之，返回end迭代器</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">lower_bound</span>(begin,end,num);</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">对于从小到大的排序数组，upper_bound()从数组的begin位置到end-1位置二分查找第一个大于等于num的数字，如果找到，则返回该数组的迭代器;反之，返回end迭代器</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">对于从大到小的排序数组，upper_bound()从数组的begin位置到end-1位置二分查找第一个小于等于num的数字，如果找到，则返回该数组的迭代器;反之，返回end迭代器</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>应用：</p>
<p>leetcode: Remove Duplicates from Sorted Array</p>
<h2 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h2><h3 id="‘unique-’"><a href="#‘unique-’" class="headerlink" title="‘unique()’"></a>‘unique()’</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">unique</span>(); <span class="comment">//用于去除相邻的重复元素（只保留一个），使用前需要对数组进行排序.</span></span><br><span class="line"><span class="comment">//实际上只是把重复元素放到数组的后方</span></span><br><span class="line"><span class="comment">//返回，去重后最后一个元素的地址</span></span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/02/28/%E5%9B%BE%E8%AE%BA1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/aa.webp">
      <meta itemprop="name" content="Sherry Wang">
      <meta itemprop="description" content="记录点滴成长">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Think World">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/02/28/%E5%9B%BE%E8%AE%BA1/" class="post-title-link" itemprop="url">图论1</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">نُشر في</span>

      <time title="أُنشأ: 2021-02-28 09:18:00" itemprop="dateCreated datePublished" datetime="2021-02-28T09:18:00+08:00">2021-02-28</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">عُدل في</span>
        <time title="عُدل: 2021-07-25 09:10:36" itemprop="dateModified" datetime="2021-07-25T09:10:36+08:00">2021-07-25</time>
      </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="图论"><a href="#图论" class="headerlink" title="图论"></a>图论</h1><h2 id="图的存储结构"><a href="#图的存储结构" class="headerlink" title="图的存储结构"></a>图的存储结构</h2><p>点：只关注顶点的编号，可以不存储;如果存储，可以使用线性表存储图的顶点集合(v1,v2,….vn)</p>
<p>边：采用邻接矩阵，邻接表，边表表示</p>
<h3 id="邻接矩阵"><a href="#邻接矩阵" class="headerlink" title="邻接矩阵"></a>邻接矩阵</h3><ul>
<li>顶点表: 用一个<strong>一维数组</strong>存储图中顶点的信息，</li>
<li>边表：用一个<strong>二维数组</strong>存储图中边的信息，存储顶点之间邻接关系的二维数组称为邻接矩阵</li>
</ul>
<p><img src="%E5%9B%BE%E8%AE%BA1/2021-02-28_16-29.png" alt="2021-02-28_16-29"></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MaxVertexNum 100</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">char</span> VertexType			<span class="comment">//顶点编号的数据类型</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> EdgeType				<span class="comment">//有权图中边上权值的数据类型</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">	VertexType Vex[MaxVertexNum]; 										<span class="comment">//顶点表，可以省略</span></span><br><span class="line">	EdgeType Edge[MaxVertexNum][MaxVertexNum]; 	<span class="comment">//边表</span></span><br><span class="line">	<span class="keyword">int</span> vexnum,arcnum;</span><br><span class="line">&#125; MGraph;</span><br></pre></td></tr></table></figure>



<h3 id="邻接表"><a href="#邻接表" class="headerlink" title="邻接表"></a>邻接表</h3><p>用线性表存储每个顶点发出的边。定长数组A[n][d],可变长数组vector</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;<span class="keyword">int</span>&gt; Grap [numP]; <span class="comment">// 有向无权图</span></span><br><span class="line">Grap[i].<span class="built_in">push_back</span>(j);<span class="comment">//增加一条边&lt;i,j &gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn =<span class="number">1e4</span>+<span class="number">10</span>;<span class="comment">//最大结点数</span></span><br><span class="line">vector&lt;pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;&gt; E[maxn];<span class="comment">//有向有权图</span></span><br><span class="line">Grap[i][j];<span class="comment">//Grap[i]访问第i个vector,每个vector作为一个动态数组，存储若干pair对，保存边的终点和权值</span></span><br><span class="line"><span class="comment">//该边的起点是i，终点是E[i].first,边的权重是E[i].second.</span></span><br></pre></td></tr></table></figure>



<h3 id="邻接链表"><a href="#邻接链表" class="headerlink" title="邻接链表"></a>邻接链表</h3><p>对于每个顶点建立一个单链表，第i个单链表中的结点包含顶点$v_i$的所有邻接顶点。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span><span class="comment">//有权图的边顶点结构</span></span><br><span class="line">    <span class="keyword">int</span> index;<span class="comment">//边的终点的下标</span></span><br><span class="line">    <span class="keyword">int</span> cost;<span class="comment">//边的权重</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span>* <span class="title">link</span>;</span><span class="comment">//指向下一条弧的指针</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">HeadNode</span>&#123;</span><span class="comment">//顶点</span></span><br><span class="line">    <span class="keyword">int</span> index;<span class="comment">//顶点的信息</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> *<span class="title">adjacent</span>;</span><span class="comment">//指向第一条依附该顶点的弧的指针</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">	HeadNode* Grap= <span class="keyword">new</span> HeadNode[vexnum];<span class="comment">//创建包含10个点的图</span></span><br><span class="line">	<span class="keyword">int</span> vexnum;<span class="comment">//顶点的个数</span></span><br><span class="line">&#125; MGraph;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p><strong>邻接链表表示无向图</strong></p>
<p><img src="%E5%9B%BE%E8%AE%BA1/2021-02-28_16-20.png" alt="2021-02-28_16-20"></p>
<h4 id="邻接链表-V-S-邻接矩阵"><a href="#邻接链表-V-S-邻接矩阵" class="headerlink" title="邻接链表 V.S. 邻接矩阵"></a>邻接链表 V.S. 邻接矩阵</h4><p><img src="%E5%9B%BE%E8%AE%BA1/2021-02-28_16-38.png" alt="2021-02-28_16-38"></p>
<h2 id="图的遍历"><a href="#图的遍历" class="headerlink" title="图的遍历"></a>图的遍历</h2><h2 id="最小生成树"><a href="#最小生成树" class="headerlink" title="最小生成树"></a>最小生成树</h2><h2 id="最短路问题"><a href="#最短路问题" class="headerlink" title="最短路问题"></a>最短路问题</h2><p>对于无权图而言，可以利用广度优先搜索查找单源最短路径</p>
<p>对于有权图而言，可以利用Dijkstra算法计算单源最短路径，利用Floyd算法计算顶点之间的最短路</p>
<h3 id="Dijkstra算法"><a href="#Dijkstra算法" class="headerlink" title="Dijkstra算法"></a>Dijkstra算法</h3><p>保存的数据:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">dist[] ;<span class="comment">//记录从源点v0到其他顶点之间的最短路径长度</span></span><br><span class="line"></span><br><span class="line">path[];<span class="comment">//记录从源点到顶点之间最短路径的前驱结点,不是必要的</span></span><br></pre></td></tr></table></figure>

<p>算法步骤：(默认源点为v0)</p>
<ul>
<li><p>初始化，集合S初始化为{0}，dist[]的初始值为 dist[i] = arcs[0][i],   i=1,2,..n-1</p>
</li>
<li><p>从顶点集合 V-S中选择出 $v_j$,满足$dist[j] =Min (dist[i]  | v_i \in V-S )$,  $ v_j$就是当前求得的，一条从v0出发的最短路径的终点</p>
</li>
<li><p>修改从v0出发到集合 V-S上的任一顶点 vk可达的最短路径长度：如果dist[j]+ arcs[j][k] &lt;dist[k] ,则更新dist[k] = sidt[j]+arcs[j][k];</p>
</li>
<li><p>重复步骤 2-3,操作共n-1次，直到所有顶点都包含在S中</p>
<p><strong>图结构采用邻接链表的方式存储</strong></p>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Created by doriswang on 2021/2/28.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> index;<span class="comment">//边的终点</span></span><br><span class="line">    <span class="keyword">int</span> cost;<span class="comment">//边的权重</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span>* <span class="title">link</span>;</span><span class="comment">//指向下一条弧的指针</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">HeadNode</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> index;<span class="comment">//顶点的信息</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> *<span class="title">adjacent</span>;</span><span class="comment">//指向第一条依附该顶点的弧的指针</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function">HeadNode* <span class="title">CreatGrap</span><span class="params">(<span class="keyword">int</span> Pnum,<span class="keyword">int</span> Enum)</span></span>&#123;</span><br><span class="line">    HeadNode* Head = <span class="keyword">new</span> HeadNode[Pnum];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;Enum;i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> strP =<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> endP= <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> cost;</span><br><span class="line">        std::cin&gt;&gt;strP&gt;&gt;endP&gt;&gt;cost;<span class="comment">//输入一条边</span></span><br><span class="line">        Node* temp = <span class="keyword">new</span> <span class="built_in">Node</span>();</span><br><span class="line">        temp-&gt;index=endP;</span><br><span class="line">        temp-&gt;cost=cost;</span><br><span class="line">        temp-&gt;link = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">if</span>(Head[strP].adjacent==<span class="literal">NULL</span>)&#123;<span class="comment">//顶点的第一条边</span></span><br><span class="line">            Head[strP].adjacent = temp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            Node* ptr=Head[strP].adjacent;</span><br><span class="line">            <span class="keyword">for</span>(;ptr-&gt;link;ptr=ptr-&gt;link)&#123;&#125;</span><br><span class="line">            ptr-&gt;link = temp;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> Head;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span>* <span class="title">Dijkstra</span><span class="params">(<span class="keyword">int</span> v,<span class="keyword">int</span> Pnum,HeadNode* Head)</span> </span>&#123;<span class="comment">//计算各个顶点到v点的最短路径</span></span><br><span class="line">    <span class="comment">//输入 strP,endP,cost ; 边的起点和终点，以及边的权重，利用邻接表存储图信息</span></span><br><span class="line">    <span class="keyword">int</span> *pre = <span class="keyword">new</span> <span class="keyword">int</span>[Pnum];<span class="comment">//保存前一个将诶点</span></span><br><span class="line">    <span class="keyword">int</span> *dist = <span class="keyword">new</span> <span class="keyword">int</span>[Pnum];</span><br><span class="line">    <span class="keyword">int</span> *s = <span class="keyword">new</span> <span class="keyword">int</span>[Pnum];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; Pnum; i++) &#123;</span><br><span class="line">        pre[i] = <span class="number">-1</span>;</span><br><span class="line">        dist[i] = <span class="number">0x0fff</span>;</span><br><span class="line">        s[i] = <span class="number">0</span>;<span class="comment">//数组s[i]=1,表示0-i的最短路径已经计算结束</span></span><br><span class="line">    &#125;</span><br><span class="line">    dist[v] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; Pnum; j++) <span class="comment">//计算n-1次</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> mindist = <span class="number">0x0fff</span>;<span class="comment">//循环：确定即将被访问的顶点u</span></span><br><span class="line">        <span class="keyword">int</span> u = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; Pnum; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (dist[i] &lt; mindist &amp;&amp; s[i] == <span class="number">0</span>) &#123;</span><br><span class="line">                mindist = dist[i];</span><br><span class="line">                u = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        s[u] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (Node *p = Head[u].adjacent; p; p = p-&gt;link) &#123;</span><br><span class="line">            <span class="keyword">int</span> k = p-&gt;index;</span><br><span class="line">            <span class="keyword">if</span> (dist[u] + p-&gt;cost &lt; dist[k]) &#123;</span><br><span class="line">                dist[k] = dist[u] + p-&gt;cost;</span><br><span class="line">                pre[k] = u;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> pre;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> Pnum=<span class="number">0</span>;<span class="comment">//顶点个数</span></span><br><span class="line">    <span class="keyword">int</span> Enum=<span class="number">0</span>;<span class="comment">//边的个数</span></span><br><span class="line">    std::cout&lt;&lt;<span class="string">&quot;依次输入顶点的个数，边的个数，以及边的起点，终点，权重&quot;</span>&lt;&lt;std::endl;</span><br><span class="line">    std::cin&gt;&gt; Pnum;</span><br><span class="line">    std::cin&gt;&gt; Enum;</span><br><span class="line">    HeadNode* headlist = <span class="built_in">CreatGrap</span>(Pnum,Enum);</span><br><span class="line">    <span class="keyword">int</span> strP = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> endP =<span class="number">0</span>;</span><br><span class="line">    std::cout&lt;&lt;<span class="string">&quot;输入你要计算最短路径的起点和终点&quot;</span>&lt;&lt;std::endl;</span><br><span class="line">    std::cin&gt;&gt;strP&gt;&gt;endP;</span><br><span class="line">    <span class="keyword">int</span>* pre = <span class="built_in">Dijkstra</span>(strP,Pnum,headlist);</span><br><span class="line">    std::cout&lt;&lt;endP;</span><br><span class="line">    <span class="keyword">int</span> end=pre[endP];</span><br><span class="line">    <span class="keyword">while</span>(end!=strP)&#123;</span><br><span class="line">        std::cout&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;end;</span><br><span class="line">        end = pre[end];</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;strP;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="两点之间的所有最短路"><a href="#两点之间的所有最短路" class="headerlink" title="两点之间的所有最短路"></a>两点之间的所有最短路</h3><h4 id="队列优化的Dijkstra算法"><a href="#队列优化的Dijkstra算法" class="headerlink" title="队列优化的Dijkstra算法"></a>队列优化的Dijkstra算法</h4><p>pat1003</p>
<h4 id="解法1（有一点问题）"><a href="#解法1（有一点问题）" class="headerlink" title="解法1（有一点问题）"></a>解法1（有一点问题）</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">AdvancedDijkstra</span><span class="params">(<span class="keyword">int</span> s)</span></span>&#123;</span><br><span class="line">    <span class="built_in">fill</span>(dis,dis+maxN,<span class="number">0x3fffffff</span>);<span class="comment">//初始化</span></span><br><span class="line">    dis[s]=<span class="number">0</span>;<span class="comment">//保存各顶点到源点之间的距离</span></span><br><span class="line">    priority_queue&lt;pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;&gt; q;<span class="comment">//默认是大根堆</span></span><br><span class="line">    q.<span class="built_in">push</span>(<span class="built_in">make_pair</span>(<span class="number">0</span>,s));</span><br><span class="line">    <span class="keyword">while</span>(!q.<span class="built_in">empty</span>())&#123;</span><br><span class="line">        <span class="keyword">int</span> u = q.<span class="built_in">top</span>().second;</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">if</span>( vis[u]==<span class="number">1</span>) <span class="keyword">continue</span>;</span><br><span class="line">        vis[u]=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;E[u].<span class="built_in">size</span>();++i)&#123;<span class="comment">//利用u到v，更新源点到v的最短路径和cost</span></span><br><span class="line">            <span class="keyword">int</span> v = E[u][i].first,w =E[u][i].second;</span><br><span class="line">            <span class="keyword">if</span>(dis[v]&gt;dis[u]+w)&#123;</span><br><span class="line">                dis[v]=dis[u]+w;</span><br><span class="line">                num[v]=num[u];</span><br><span class="line">                pre[v].<span class="built_in">clear</span>();</span><br><span class="line">                pre[v].<span class="built_in">push_back</span>(u);</span><br><span class="line">                MaxCost[v]=MaxCost[u]+cost[v];<span class="comment">//更新最短路，必须更新MaxCost</span></span><br><span class="line">                <span class="keyword">if</span>(vis[v]==<span class="number">0</span>) q.<span class="built_in">push</span>(<span class="built_in">make_pair</span>(-dis[v],v));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(dis[v]==dis[u]+w)&#123;</span><br><span class="line">                pre[v].<span class="built_in">push_back</span>(u);</span><br><span class="line">                num[v]+=num[u];</span><br><span class="line">                <span class="keyword">if</span>(MaxCost[v]&lt;MaxCost[u]+cost[v])&#123;</span><br><span class="line">                    MaxCost[v]=MaxCost[u]+cost[v];</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(vis[v]==<span class="number">0</span>) q.<span class="built_in">push</span>(<span class="built_in">make_pair</span>(-dis[v],v));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="解法2："><a href="#解法2：" class="headerlink" title="解法2："></a>解法2：</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MaxN = <span class="number">510</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">0x3fffffff</span>;</span><br><span class="line"><span class="keyword">int</span> edge[MaxN][MaxN],dist[MaxN],num[MaxN],MaxCost[MaxN],Cost[MaxN];</span><br><span class="line"><span class="keyword">bool</span> vis[MaxN];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Dijkstra</span><span class="params">(<span class="keyword">int</span> s,<span class="keyword">int</span> numP)</span></span>&#123;</span><br><span class="line">    num[s]=<span class="number">1</span>;</span><br><span class="line">    MaxCost[s]=Cost[s];</span><br><span class="line">    dist[s]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;numP;i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> MinDis = INF;</span><br><span class="line">        <span class="keyword">int</span> u=<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;numP;j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (MinDis &gt; dist[j] &amp;&amp; !vis[j]) &#123;</span><br><span class="line">                MinDis = dist[j];</span><br><span class="line">                u = j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(u==<span class="number">-1</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        vis[u]=<span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;numP;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(edge[u][j]+dist[u]&lt;dist[j])&#123;</span><br><span class="line">                dist[j]=edge[u][j]+dist[u];</span><br><span class="line">                num[j]=num[u];</span><br><span class="line">                MaxCost[j]=MaxCost[u]+Cost[j];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(edge[u][j]+dist[u] == dist[j])&#123;</span><br><span class="line">                num[j]+=num[u];</span><br><span class="line">                <span class="keyword">if</span>(MaxCost[j]&lt;MaxCost[u]+Cost[j])&#123;</span><br><span class="line">                    MaxCost[j]=MaxCost[u]+Cost[j];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/02/24/STL-map/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/aa.webp">
      <meta itemprop="name" content="Sherry Wang">
      <meta itemprop="description" content="记录点滴成长">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Think World">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/02/24/STL-map/" class="post-title-link" itemprop="url">STL-map</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">نُشر في</span>

      <time title="أُنشأ: 2021-02-24 10:14:27" itemprop="dateCreated datePublished" datetime="2021-02-24T10:14:27+08:00">2021-02-24</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">عُدل في</span>
        <time title="عُدل: 2021-03-22 02:20:38" itemprop="dateModified" datetime="2021-03-22T02:20:38+08:00">2021-03-22</time>
      </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="STL中map的基本用法"><a href="#STL中map的基本用法" class="headerlink" title="STL中map的基本用法"></a>STL中map的基本用法</h1><h2 id="pair"><a href="#pair" class="headerlink" title="pair"></a>pair</h2><p>map中存储的基本数据类型是pair,首先我们简单介绍一下pair的基本结构</p>
<p>pair 定义在&lt;map.h&gt;中，</p>
<p><strong>pair</strong>是有两个变量的结构体，变量的默认权限是public，都可以访问，只是first设置为const，不能修改键值</p>
<h3 id="底层实现"><a href="#底层实现" class="headerlink" title="底层实现"></a>底层实现</h3><h4 id="结构定义"><a href="#结构定义" class="headerlink" title="结构定义"></a>结构定义</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T1</span>,<span class="keyword">class</span> <span class="title">T2</span>&gt;</span></span><br><span class="line">   <span class="class"><span class="keyword">struct</span> <span class="title">pair</span>&#123;</span></span><br><span class="line">       <span class="keyword">typedef</span> T1 first_type;</span><br><span class="line">       <span class="keyword">typedef</span> T2 second_type;</span><br><span class="line">       </span><br><span class="line">       T1 first;</span><br><span class="line">       T2 second;</span><br><span class="line">       </span><br><span class="line">       <span class="built_in">pair</span>(): <span class="built_in">first</span>(<span class="built_in">T1</span>()) ,<span class="built_in">second</span>(<span class="built_in">T2</span>())&#123;&#125;</span><br><span class="line">       </span><br><span class="line">       <span class="built_in">pair</span>(<span class="keyword">const</span> T1&amp; a,<span class="keyword">const</span> T2&amp; b): <span class="built_in">first</span>(a) ,<span class="built_in">second</span>(b) &#123; &#125;</span><br><span class="line">     <span class="meta">#<span class="meta-keyword">ifdef</span>	__STL_MEMBER_TEMPLATES</span></span><br><span class="line">       <span class="function"><span class="keyword">template</span>&lt;class U1,class U2&gt;</span></span><br><span class="line"><span class="function">       <span class="title">pair</span><span class="params">(<span class="keyword">const</span> pair&lt;U1,U2&gt;&amp; p)</span> :dirst(p.first),second(p.second)&#123;</span>&#125;</span><br><span class="line">       <span class="meta">#<span class="meta-keyword">endif</span>  </span></span><br><span class="line">   &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="重载"><a href="#重载" class="headerlink" title="重载"></a>重载</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T1</span>, <span class="keyword">class</span> <span class="title">T2</span>&gt;</span></span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="keyword">operator</span>==(<span class="keyword">const</span> pair&lt;T1, T2&gt;&amp; x, <span class="keyword">const</span> pair&lt;T1, T2&gt;&amp; y) &#123; </span><br><span class="line">  <span class="keyword">return</span> x.first == y.first &amp;&amp; x.second == y.second; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T1</span>, <span class="keyword">class</span> <span class="title">T2</span>&gt;</span></span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="keyword">operator</span>&lt;(<span class="keyword">const</span> pair&lt;T1, T2&gt;&amp; x, <span class="keyword">const</span> pair&lt;T1, T2&gt;&amp; y) &#123; </span><br><span class="line">  <span class="keyword">return</span> x.first &lt; y.first || (!(y.first &lt; x.first) &amp;&amp; x.second &lt; y.second); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="成员函数-make-pair"><a href="#成员函数-make-pair" class="headerlink" title="成员函数 make_pair"></a>成员函数 make_pair</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;class T1, classT2&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> pair&lt;T1,T2&gt; <span class="title">make_pair</span><span class="params">(<span class="keyword">const</span> T1&amp; x,<span class="keyword">const</span> T2&amp; y)</span></span>&#123;</span><br><span class="line">		<span class="keyword">return</span> pair&lt;T1,T2&gt;(x,y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="map"><a href="#map" class="headerlink" title="map"></a>map</h2><p>map存储的基本数据类型是pair,数据结构是RB-tree，可以理解为关联数组。可以使用键作为下标来获得相应的值。关联的本质在于元素的值与某个特定的键相关联。</p>
<p>map元素的键值是唯一的，multimap允许重复元素</p>
<p>map的insert必须是以pair为存储结构，当然也可以直接使用make_pair构造一个临时pair</p>
<h3 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">map c / multimap c; //产生一个空的map或者multimap，不包含任何因素</span></span><br><span class="line"><span class="comment">map c(op) / multimap c(op); //以op为排序准则，产生一个空的map</span></span><br><span class="line"><span class="comment">map c1(c2) / multimap c1(c2) ; //产生某个map或者multimap对象的副本，所有元素均被复制</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">map c(beg,end) /multimap c(beg,end); //以区间(beg,end)内的元素产生一个新的map/multimap</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">map c(beg,end,op) / multimap c(beg,end,op) //以区间(beg,end)内的元素产生一个新的map/multimap，排序准则为op</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line"></span><br><span class="line">map&lt;<span class="keyword">int</span>,<span class="keyword">double</span>&gt;  m1;</span><br><span class="line">map&lt;<span class="keyword">int</span>,<span class="keyword">double</span>,greater&lt;<span class="keyword">int</span>&gt;&gt; m2; <span class="comment">//降序排列</span></span><br><span class="line">map&lt;<span class="keyword">int</span>,<span class="keyword">double</span>,less&lt;<span class="keyword">int</span>&gt;&gt; m3; <span class="comment">//升序排列</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//采用插入方式，增加元素</span></span><br><span class="line"><span class="comment">//对应迭代器的声明</span></span><br><span class="line">map&lt;<span class="keyword">int</span> ,<span class="keyword">double</span>&gt;::iterator itm;</span><br></pre></td></tr></table></figure>

<h3 id="增加元素"><a href="#增加元素" class="headerlink" title="增加元素"></a>增加元素</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">    <span class="comment">//方式1：提前先定义好pair</span></span><br><span class="line">	pair&lt;string, <span class="keyword">int</span>&gt; p;</span><br><span class="line">	p.first = <span class="string">&quot;zero&quot;</span>, p.second = <span class="number">0</span>;</span><br><span class="line">	m.<span class="built_in">insert</span>(p); </span><br><span class="line">    </span><br><span class="line">    <span class="comment">//方式2：使用make_pair方式创建临时pair对象</span></span><br><span class="line">	m.<span class="built_in">insert</span>(<span class="built_in">make_pair</span>(<span class="string">&quot;one&quot;</span>, <span class="number">1</span>));</span><br><span class="line">	</span><br><span class="line"><span class="comment">////[key] 自动添加，参考符号重载</span></span><br><span class="line">	m[<span class="string">&quot;two&quot;</span>]=<span class="number">3</span>;</span><br><span class="line">	</span><br><span class="line">	std::cout&lt;&lt;m[<span class="string">&quot;three&quot;</span>]; <span class="comment">//输出0,默认值</span></span><br></pre></td></tr></table></figure>



<h3 id="基本属性获取"><a href="#基本属性获取" class="headerlink" title="基本属性获取"></a>基本属性获取</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">map</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	...</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 实际调用的是RB-tree的key_comp函数</span></span><br><span class="line">  <span class="function">key_compare <span class="title">key_comp</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> t.<span class="built_in">key_comp</span>(); &#125;</span><br><span class="line">    <span class="comment">// value_comp实际返回的是一个仿函数value_compare</span></span><br><span class="line">  <span class="function">value_compare <span class="title">value_comp</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> <span class="built_in">value_compare</span>(t.<span class="built_in">key_comp</span>()); &#125;</span><br><span class="line">    <span class="comment">// 以下的begin, end等操作都是调用的是RB-tree的接口</span></span><br><span class="line">    </span><br><span class="line">   <span class="comment">//迭代器</span></span><br><span class="line">  <span class="function">iterator <span class="title">begin</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> t.<span class="built_in">begin</span>(); &#125;</span><br><span class="line">  <span class="function">const_iterator <span class="title">begin</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> t.<span class="built_in">begin</span>(); &#125;</span><br><span class="line">    </span><br><span class="line">  <span class="function">iterator <span class="title">end</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> t.<span class="built_in">end</span>(); &#125;</span><br><span class="line">  <span class="function">const_iterator <span class="title">end</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> t.<span class="built_in">end</span>(); &#125;</span><br><span class="line">    </span><br><span class="line">   </span><br><span class="line">  <span class="function">reverse_iterator <span class="title">rbegin</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> t.<span class="built_in">rbegin</span>(); &#125;</span><br><span class="line">  <span class="function">const_reverse_iterator <span class="title">rbegin</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> t.<span class="built_in">rbegin</span>(); &#125;</span><br><span class="line">  <span class="function">reverse_iterator <span class="title">rend</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> t.<span class="built_in">rend</span>(); &#125;</span><br><span class="line">  <span class="function">const_reverse_iterator <span class="title">rend</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> t.<span class="built_in">rend</span>(); &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//判断是否为空</span></span><br><span class="line">  <span class="function"><span class="keyword">bool</span> <span class="title">empty</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> t.<span class="built_in">empty</span>(); &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//计算尺寸</span></span><br><span class="line">  <span class="function">size_type <span class="title">size</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> t.<span class="built_in">size</span>(); &#125;</span><br><span class="line">  <span class="function">size_type <span class="title">max_size</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> t.<span class="built_in">max_size</span>(); &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 交换, 调用RB-tree的swap, 实际只交换count</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(map&lt;Key k, T t, Compare, Alloc&gt;&amp; x)</span> </span>&#123; t.<span class="built_in">swap</span>(x.t); &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">Key</span>, <span class="keyword">class</span> <span class="title">T</span>, <span class="keyword">class</span> <span class="title">Compare</span>, <span class="keyword">class</span> <span class="title">Alloc</span>&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(map&lt;Key, T, Compare, Alloc&gt;&amp; x, </span></span></span><br><span class="line"><span class="params"><span class="function">                 map&lt;Key, T, Compare, Alloc&gt;&amp; y)</span> </span>&#123;</span><br><span class="line">  x.<span class="built_in">swap</span>(y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="重载-1"><a href="#重载-1" class="headerlink" title="重载"></a>重载</h3><h4 id="lt"><a href="#lt" class="headerlink" title="==,&lt;"></a><code>==</code>,<code>&lt;</code></h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//大小比较，取决于值的大小</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">map</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	...</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">map</span>(<span class="keyword">const</span> map&lt;Key, T, Compare, Alloc&gt;&amp; x) : <span class="built_in">t</span>(x.t) &#123;&#125;</span><br><span class="line">  map&lt;Key, T, Compare, Alloc&gt;&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> map&lt;Key, T, Compare, Alloc&gt;&amp; x)</span><br><span class="line">  &#123;</span><br><span class="line">    t = x.t;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>; </span><br><span class="line">  &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">Key</span>, <span class="keyword">class</span> <span class="title">T</span>, <span class="keyword">class</span> <span class="title">Compare</span>, <span class="keyword">class</span> <span class="title">Alloc</span>&gt;</span></span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="keyword">operator</span>==(<span class="keyword">const</span> map&lt;Key, T, Compare, Alloc&gt;&amp; x, </span><br><span class="line">                       <span class="keyword">const</span> map&lt;Key, T, Compare, Alloc&gt;&amp; y) &#123;</span><br><span class="line">  <span class="keyword">return</span> x.t == y.t;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">Key</span>, <span class="keyword">class</span> <span class="title">T</span>, <span class="keyword">class</span> <span class="title">Compare</span>, <span class="keyword">class</span> <span class="title">Alloc</span>&gt;</span></span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="keyword">operator</span>&lt;(<span class="keyword">const</span> map&lt;Key, T, Compare, Alloc&gt;&amp; x, </span><br><span class="line">                      <span class="keyword">const</span> map&lt;Key, T, Compare, Alloc&gt;&amp; y) &#123;</span><br><span class="line">  <span class="keyword">return</span> x.t &lt; y.t;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id=""><a href="#" class="headerlink" title="[]"></a><code>[]</code></h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">map</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	...</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 1.  insert(value_type(k, T()) : 查找是否存在该键值, 如果存在则返回该pair, 不存在这重新构造一该键值并且值为空</span></span><br><span class="line">	<span class="comment">// 2.  *((insert(value_type(k, T()))).first) : pair的第一个元素表示指向该元素的迭代器, 第二个元素指的是(false与true)是否存在,  first 便是取出该迭代器而 * 取出pair.</span></span><br><span class="line">	<span class="comment">// 3.  (*((insert(value_type(k, T()))).first)).second : 取出pair结构中的second保存的数据</span></span><br><span class="line">  T&amp; <span class="keyword">operator</span>[](<span class="keyword">const</span> key_type&amp; k) &#123;</span><br><span class="line">    <span class="keyword">return</span> ( *(  (  <span class="built_in">insert</span>(<span class="built_in">value_type</span>(k, <span class="built_in">T</span>()))   ).first)  ).second;</span><br><span class="line">  &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h3 id="常用操作"><a href="#常用操作" class="headerlink" title="常用操作"></a>常用操作</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//swap() ,交换两个键值的内容</span></span><br><span class="line">std::cout&lt;&lt;mm[<span class="string">&quot;1&quot;</span>]&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;mm[<span class="string">&quot;2&quot;</span>]&lt;&lt;std::endl;</span><br><span class="line">std::<span class="built_in">swap</span>(mm[<span class="string">&quot;1&quot;</span>],mm[<span class="string">&quot;2&quot;</span>]); </span><br><span class="line">std::cout&lt;&lt;mm[<span class="string">&quot;1&quot;</span>]&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;mm[<span class="string">&quot;2&quot;</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">//erase</span></span><br><span class="line">iterator erase（iterator it);<span class="comment">//通过一个条目对象删除</span></span><br><span class="line"></span><br><span class="line">iterator erase（iterator first，iterator last）<span class="comment">//删除一个范围</span></span><br><span class="line"></span><br><span class="line"><span class="function">size_type <span class="title">erase</span><span class="params">(<span class="keyword">const</span> Key&amp;key)</span></span>;<span class="comment">//通过关键字删除</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">clear</span>()<span class="comment">//就相当于enumMap.erase(enumMap.begin(),enumMap.end());</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//count(const Key&amp; key)</span></span><br><span class="line"><span class="function">size_type <span class="title">count</span><span class="params">(<span class="keyword">const</span> Key&amp; key )</span>  <span class="keyword">const</span></span>;<span class="comment">//函数功能是返回元素在map/multimap中出现的次数。对于map型容器，返回值只有 0/1</span></span><br><span class="line">    </span><br><span class="line"></span><br><span class="line"><span class="comment">//find,其功能是返回指向key的迭代器。如果键值key对应的元素不存在，在函数返回迭代器end()</span></span><br><span class="line"><span class="function">iterator <span class="title">find</span><span class="params">(<span class="keyword">const</span> Key&amp; key)</span></span>;</span><br><span class="line"><span class="function">const_iterator <span class="title">find</span><span class="params">(<span class="keyword">const</span> Key&amp; key )</span> <span class="keyword">const</span></span>;</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="补充1"><a href="#补充1" class="headerlink" title="补充1:"></a>补充1:</h3><p>在STL中，map,set，multimap，multiset底层都是用红黑树实现，都是有序的</p>
<p>相关操作的复杂度</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">插入: O(logN)</span><br><span class="line">查看:O(logN)</span><br><span class="line">删除:O(logN)</span><br></pre></td></tr></table></figure>

<p>hash_map, hash_set, hash_multimap, and hash_multiset<br> 上述四种容器采用哈希表实现，不同操作的时间复杂度为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">插入:O(1)，最坏情况O(N)</span><br><span class="line"> 查看:O(1)，最坏情况O(N)</span><br><span class="line"> 删除:O(1)，最坏情况O(N)。</span><br></pre></td></tr></table></figure>

<p>unordered_map 和 hash_map的内部结构都是用哈希表来实现，但是在C++11中，hash_map已经被舍弃了，最好建议使用unordered_map</p>
<p>更详细的相关区别： <a target="_blank" rel="noopener" href="https://blog.csdn.net/chen134225/article/details/83106569">https://blog.csdn.net/chen134225/article/details/83106569</a></p>
<p>参考资料：</p>
<p><a target="_blank" rel="noopener" href="https://github.com/GritCS/STL/blob/master/30%20map.md">https://github.com/GritCS/STL/blob/master/30%20map.md</a></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/02/22/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/aa.webp">
      <meta itemprop="name" content="Sherry Wang">
      <meta itemprop="description" content="记录点滴成长">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Think World">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/02/22/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/" class="post-title-link" itemprop="url">排序算法总结</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">نُشر في</span>

      <time title="أُنشأ: 2021-02-22 13:47:29" itemprop="dateCreated datePublished" datetime="2021-02-22T13:47:29+08:00">2021-02-22</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">عُدل في</span>
        <time title="عُدل: 2021-07-25 09:12:57" itemprop="dateModified" datetime="2021-07-25T09:12:57+08:00">2021-07-25</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">في</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E4%BF%9D%E7%A0%94/" itemprop="url" rel="index"><span itemprop="name">保研</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="总览"><a href="#总览" class="headerlink" title="总览"></a>总览</h1><h1 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h1><p><strong>每次将一个待排序的记录按照其关键字的大小插到前面已经排好序的子序列中</strong></p>
<h2 id="直接插入排序"><a href="#直接插入排序" class="headerlink" title="直接插入排序"></a>直接插入排序</h2><h3 id="源码实现"><a href="#源码实现" class="headerlink" title="源码实现"></a>源码实现</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InsertSort</span><span class="params">(T A[], <span class="keyword">int</span> length)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;length;++i)&#123;</span><br><span class="line">        <span class="keyword">if</span>(A[i]&lt;A[i<span class="number">-1</span>])&#123;<span class="comment">//前0-i-1个元素是排好序的元素,</span></span><br><span class="line">            <span class="comment">// 如果A[i]&gt;A[i-1]不移动元素</span></span><br><span class="line">            <span class="keyword">int</span> temp = A[i];</span><br><span class="line">            <span class="keyword">int</span> j;</span><br><span class="line">            <span class="keyword">for</span>(j=i<span class="number">-1</span>;(temp&lt;A[j])&amp;&amp;(j&gt;=<span class="number">0</span>);--j)&#123;</span><br><span class="line">                A[j+<span class="number">1</span>]=A[j];</span><br><span class="line">            &#125;</span><br><span class="line">            A[j+<span class="number">1</span>]=temp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="性能分析"><a href="#性能分析" class="headerlink" title="性能分析"></a>性能分析</h3><table>
<thead>
<tr>
<th></th>
<th>最好</th>
<th>最坏</th>
<th>平均</th>
</tr>
</thead>
<tbody><tr>
<td>时间</td>
<td>O(n) //只需要比较，不需要移动</td>
<td>$O(n^2)$</td>
<td>$O(n^2)$</td>
</tr>
<tr>
<td>空间</td>
<td>O(1)</td>
<td>O(1)</td>
<td>$O(1)$</td>
</tr>
</tbody></table>
<p><strong>稳定性：稳定性的排序方法（数值大小相同的元素排序前后的相对位置不变）</strong></p>
<p><strong>适用性：适用于顺序存储和链式存储的线性表</strong></p>
<p>由于当数据基本有序时，时间复杂度趋于线性，更适用于基本有序的排序表和数据量不大的排序表</p>
<h2 id="折半插入排序"><a href="#折半插入排序" class="headerlink" title="折半插入排序"></a>折半插入排序</h2><p>利用折半查找优化直接插入排序</p>
<h3 id="源码实现-1"><a href="#源码实现-1" class="headerlink" title="源码实现"></a>源码实现</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt; class T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InsertSort2</span><span class="params">(T A[] ,<span class="keyword">int</span> len)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;len;i++)&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(A[i]&lt;A[i<span class="number">-1</span>])&#123;</span><br><span class="line">            <span class="keyword">int</span> temp = A[i];</span><br><span class="line">            <span class="comment">//利用折半查找，找到要插入的元素;</span></span><br><span class="line">            <span class="keyword">int</span> start = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">int</span> end=i<span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">while</span>(start&lt;end )&#123;</span><br><span class="line">                <span class="keyword">int</span> mid = (start+end)/<span class="number">2</span>;</span><br><span class="line">                <span class="keyword">if</span>(A[mid]&lt;temp)&#123;<span class="comment">//要插入的元素，应该是在右边，找到第一个大于temp的</span></span><br><span class="line">                    start=mid+<span class="number">1</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    end = mid;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="comment">//跳出该循环的条件是，end=start，其中end指向最左侧大于A[i]的下标</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=i<span class="number">-1</span>;j&gt;=end;j--)&#123;</span><br><span class="line">                A[j+<span class="number">1</span>]=A[j];</span><br><span class="line">            &#125;</span><br><span class="line">            A[end]=temp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="性能分析-1"><a href="#性能分析-1" class="headerlink" title="性能分析"></a>性能分析</h3><p><img src="%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/2021-02-22_21-02.png" alt="2021-02-22_21-02"></p>
<h2 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h2><p>由于直接插入排序算法更适用于 基本有序的排序表和数据量不大的排序表。</p>
<p>希尔排序基于这两点进行改进，缩小增量排序</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;class T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ShellSort</span><span class="params">(T A[],<span class="keyword">int</span> len)</span></span>&#123;</span><br><span class="line">   <span class="keyword">for</span>(<span class="keyword">int</span> d =len/<span class="number">2l</span>;d&gt;<span class="number">1</span>;d=d/<span class="number">2</span>)&#123;</span><br><span class="line">       <span class="keyword">for</span>(<span class="keyword">int</span> i=d+<span class="number">1</span>;i&lt;len;i++)<span class="comment">//起始位置</span></span><br><span class="line">       &#123;</span><br><span class="line">           <span class="keyword">if</span> (A[i] &lt; A[i - d]) &#123;</span><br><span class="line">               <span class="keyword">int</span> temp = A[i];</span><br><span class="line">               <span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line">               <span class="keyword">for</span> (j = i - d; j &gt; <span class="number">0</span> &amp;&amp; temp &lt; A[j]; j -= d) &#123;</span><br><span class="line">                   A[j + d] = A[j];</span><br><span class="line">               &#125;</span><br><span class="line">               A[j + d] = temp;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="交换排序"><a href="#交换排序" class="headerlink" title="交换排序"></a>交换排序</h1><p><strong>交换：跟据序列中两个元素关键点的比较结果来对换这两个记录在序列中的位置</strong></p>
<h2 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h2><p>从后往前两两比较相邻元素的值，</p>
<h3 id="源码实现-2"><a href="#源码实现-2" class="headerlink" title="源码实现"></a>源码实现</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;class T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BubbleSort</span><span class="params">(T A[] , <span class="keyword">int</span> len)</span></span>&#123;</span><br><span class="line">	<span class="keyword">bool</span> flag = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">while</span>(!flag)&#123;</span><br><span class="line">        flag = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;len<span class="number">-1</span>;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(A[i]&gt;A[i+<span class="number">1</span>])&#123;</span><br><span class="line">                    std::<span class="built_in">swap</span>(A[i],A[i+<span class="number">1</span>]);</span><br><span class="line">                    flag = <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="性能分析-2"><a href="#性能分析-2" class="headerlink" title="性能分析"></a>性能分析</h3><table>
<thead>
<tr>
<th></th>
<th>最好</th>
<th>最坏</th>
<th>平均</th>
</tr>
</thead>
<tbody><tr>
<td>时间</td>
<td>O(n) //只需要比较，不需要移动</td>
<td>$O(n^2)$</td>
<td>$O(n^2)$</td>
</tr>
<tr>
<td>空间</td>
<td>O(1)</td>
<td>O(1)</td>
<td>$O(1)$</td>
</tr>
</tbody></table>
<p>稳定的排序方法</p>
<h2 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h2><p>基于分治的思想</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;class T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Partition</span><span class="params">(T A[], <span class="keyword">int</span> start,<span class="keyword">int</span> end)</span></span>&#123;</span><br><span class="line">    T base = A[start];</span><br><span class="line">    <span class="keyword">int</span> low=start;</span><br><span class="line">    <span class="keyword">int</span> high=end;</span><br><span class="line">    <span class="keyword">while</span>(low&lt;high)&#123;<span class="comment">//low指向小于等于元素，high指向大于元素</span></span><br><span class="line">        <span class="keyword">while</span>(A[low]&lt;=base)&#123;<span class="comment">//会自动跳过base</span></span><br><span class="line">            low++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(A[high]&gt;base)&#123;</span><br><span class="line">            high--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(low&lt;high)&#123;</span><br><span class="line">            std::<span class="built_in">swap</span>(A[low],A[high]);<span class="comment">//交换两个</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    std::<span class="built_in">swap</span>(A[high],A[start]);<span class="comment">//high指向最右侧的最大元素</span></span><br><span class="line">    <span class="keyword">return</span> high;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;class T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">QuickSort</span><span class="params">(T A[],<span class="keyword">int</span> start, <span class="keyword">int</span> end)</span></span>&#123;</span><br><span class="line">    <span class="comment">//不断分治</span></span><br><span class="line">    <span class="keyword">if</span>(start&lt;end)&#123;</span><br><span class="line">        <span class="keyword">int</span> mid = <span class="built_in">Partition</span>(A,start,end);</span><br><span class="line">        <span class="built_in">QuickSort</span>(A,start,mid<span class="number">-1</span>);</span><br><span class="line">        <span class="built_in">QuickSort</span>(A,mid+<span class="number">1</span>,end);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="性能分析-3"><a href="#性能分析-3" class="headerlink" title="性能分析"></a>性能分析</h3><table>
<thead>
<tr>
<th></th>
<th>最好</th>
<th>最坏</th>
<th>平均</th>
</tr>
</thead>
<tbody><tr>
<td>时间</td>
<td>O(log_ n) //只需要比较，不需要移动</td>
<td>$O(n)$</td>
<td>$O(log_2 n)$</td>
</tr>
<tr>
<td>空间</td>
<td>$O(n *log_2 n)$</td>
<td>$O(n^2)$</td>
<td>约等于$O(n*log_2 n)$</td>
</tr>
</tbody></table>
<p><strong>最快的内部排序，不稳定的排序方法</strong></p>
<h1 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h1><h2 id="简单选择排序"><a href="#简单选择排序" class="headerlink" title="简单选择排序"></a>简单选择排序</h2><p>选择排序基本思想：每一趟在后面n-i-1个待排序元素中选取关键字最小的元素;作为有序子序列的第i个元素，直到第n-1趟做完，待排序元素只剩下一个就不用再选了</p>
<h3 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h3><p><img src="%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/2021-02-22_23-32.png" alt="2021-02-22_23-32"></p>
<h3 id="性能分析-4"><a href="#性能分析-4" class="headerlink" title="性能分析"></a>性能分析</h3><table>
<thead>
<tr>
<th></th>
<th>最好</th>
<th>最坏</th>
<th>平均</th>
</tr>
</thead>
<tbody><tr>
<td>时间</td>
<td>O(n) //只需要比较，不需要移动</td>
<td>$O(n^2)$</td>
<td>$O(n^2)$</td>
</tr>
<tr>
<td>空间</td>
<td>O(1)</td>
<td>O(1)</td>
<td>$O(1)$</td>
</tr>
</tbody></table>
<p>不稳定的排序方法</p>
<h2 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h2><h3 id="源码实现-大根堆为例"><a href="#源码实现-大根堆为例" class="headerlink" title="源码实现(大根堆为例)"></a>源码实现(大根堆为例)</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">HeapSort</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="comment">//初始建堆</span></span><br><span class="line">    <span class="built_in">build</span>();</span><br><span class="line">    <span class="comment">//堆排序</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n<span class="number">-1</span>;i++)&#123;</span><br><span class="line">        <span class="built_in">swap</span>(<span class="number">1</span>,hlen);</span><br><span class="line">        hlen--;</span><br><span class="line">        <span class="built_in">down</span>(<span class="number">1</span>); <span class="comment">//不断删除最大结点</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a target="_blank" rel="noopener" href="https://gritcs.github.io/2021/02/20/%E5%A0%86/">之前总结过堆的相关笔记</a></p>
<h3 id="性能分析-5"><a href="#性能分析-5" class="headerlink" title="性能分析"></a>性能分析</h3><table>
<thead>
<tr>
<th></th>
<th>最好</th>
<th>最坏</th>
<th>平均</th>
</tr>
</thead>
<tbody><tr>
<td>时间</td>
<td>$O(n *log_2 n)$</td>
<td>$O(n *log_2 n)$</td>
<td>$O(n *log_2 n)$</td>
</tr>
<tr>
<td>空间</td>
<td>O(1)</td>
<td>O(1)</td>
<td>$O(1)$</td>
</tr>
</tbody></table>
<p><strong>不稳定的排序方法</strong></p>
<h1 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h1><p><strong>”归并“的含义是将两个或者两个以上的有序表</strong>组合成一个新的有序表。</p>
<h3 id="源码实现-3"><a href="#源码实现-3" class="headerlink" title="源码实现"></a>源码实现</h3><p><strong>迭代实现版本</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">template</span>&lt;class T&gt;</span></span><br><span class="line"><span class="function"> <span class="keyword">void</span> <span class="title">Merge</span><span class="params">(T A[], <span class="keyword">int</span> left,<span class="keyword">int</span> mid,<span class="keyword">int</span> right)</span></span>&#123;</span><br><span class="line">     <span class="keyword">int</span> i=left;</span><br><span class="line">     <span class="keyword">int</span> j=mid;</span><br><span class="line">     <span class="keyword">int</span> size = right-left;</span><br><span class="line">     T* B= <span class="keyword">new</span> <span class="built_in">T</span>(size);</span><br><span class="line">     <span class="keyword">int</span> k=<span class="number">0</span>;</span><br><span class="line">     <span class="keyword">while</span>(i&lt;mid&amp;&amp;j&lt;right)&#123;</span><br><span class="line">         <span class="keyword">if</span>(A[i]&lt;A[j])&#123;<span class="comment">//A[i]在前</span></span><br><span class="line">             B[k]=A[i];</span><br><span class="line">             i++;</span><br><span class="line">             k++;</span><br><span class="line">         &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">             B[k]=A[j];</span><br><span class="line">             j++;</span><br><span class="line">             k++;</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">if</span>(i&lt;mid)&#123;</span><br><span class="line">         <span class="keyword">while</span>(i&lt;mid)&#123;</span><br><span class="line">             B[k++]=A[i++];</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">if</span>(j&lt;right)&#123;</span><br><span class="line">         <span class="keyword">while</span>(j&lt;right)&#123;</span><br><span class="line">             B[k++]=A[j++];</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">0</span>;k&lt;size;k++)&#123;</span><br><span class="line">         A[k+left]=B[k];</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;class T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MergeSort</span><span class="params">(T A[],<span class="keyword">int</span> len)</span></span>&#123;</span><br><span class="line">    T *B=<span class="keyword">new</span> T[len];</span><br><span class="line">   <span class="keyword">int</span> d=<span class="number">1</span>;</span><br><span class="line">   <span class="keyword">int</span> start=<span class="number">0</span>;</span><br><span class="line">   <span class="keyword">int</span> end=len;</span><br><span class="line">   <span class="keyword">while</span>(start+d&lt;=end)&#123;</span><br><span class="line">       <span class="keyword">for</span>(<span class="keyword">int</span> i=start;i&lt;=end;i+=<span class="number">2</span>*d)&#123;</span><br><span class="line">           <span class="keyword">if</span>(i+<span class="number">2</span>*d&lt;end)</span><br><span class="line">           &#123;</span><br><span class="line">               <span class="built_in">Merge</span>(A,i,i+d,i+<span class="number">2</span>*d);<span class="comment">//左闭右开</span></span><br><span class="line">           &#125;<span class="keyword">else</span> <span class="keyword">if</span>(i+d&lt;end)&#123;</span><br><span class="line">               <span class="built_in">Merge</span>(A,i,i+d,end);</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="comment">//剩余一个数组，不需要排序</span></span><br><span class="line">       &#125;</span><br><span class="line">       d=d&lt;&lt;<span class="number">1</span>;<span class="comment">//乘2</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th></th>
<th>最好</th>
<th>最坏</th>
<th>平均</th>
</tr>
</thead>
<tbody><tr>
<td>时间</td>
<td>$O(n *log_2 n)$</td>
<td>$O(n *log_2 n)$</td>
<td>$O(n *log_2 n)$</td>
</tr>
<tr>
<td>空间</td>
<td>O(n)</td>
<td>O(n)</td>
<td>$O(n)$</td>
</tr>
</tbody></table>
<p>是一种稳定的排序方式</p>
<h2 id="基数排序"><a href="#基数排序" class="headerlink" title="基数排序"></a>基数排序</h2><p>不基于比较和移动进行排序，而是基于关键字各位的大小进行排序</p>
<p>最高次序位法(MSD)：先最高位进行分桶，对桶内记录进行排序，然后按次高位排序，最后按最低位排序。</p>
<p>最低次序位法(LSD)：首先按最低位排序，然后按下一个次低位排序，..，最后按最高位排序。</p>
<p><strong>比较适合链表结构，辅助空间：r+1个队头指针和队尾指针，n个link域</strong></p>
<p>一般如果r&lt;&lt;n,时间复杂度是O(n p)</p>
<h3 id="源码实现-4"><a href="#源码实现-4" class="headerlink" title="源码实现"></a>源码实现</h3><p>略</p>
<h1 id="内排序总结"><a href="#内排序总结" class="headerlink" title="内排序总结"></a>内排序总结</h1><p>如果文件的初始状态已经按关键字基本有序，则选用直接插入或者冒泡排序。</p>
<p><strong>在基于比较的排序方法中，每次比较两个关键字的大小之后，仅仅出现两种可能的转移。任何借助“比较”的排序算法，至少需要$O(nlog^2n)$</strong></p>
<p><img src="%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/%E6%8E%92%E5%BA%8F.png" alt="排序"></p>
<img src="排序算法总结/2021-02-24_13-01.png" alt="2021-02-24_13-01" style="zoom:200%;" />


      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/02/20/%E5%A0%86/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/aa.webp">
      <meta itemprop="name" content="Sherry Wang">
      <meta itemprop="description" content="记录点滴成长">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Think World">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/02/20/%E5%A0%86/" class="post-title-link" itemprop="url">堆</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">نُشر في</span>

      <time title="أُنشأ: 2021-02-20 20:23:37" itemprop="dateCreated datePublished" datetime="2021-02-20T20:23:37+08:00">2021-02-20</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">عُدل في</span>
        <time title="عُدل: 2021-02-25 04:10:38" itemprop="dateModified" datetime="2021-02-25T04:10:38+08:00">2021-02-25</time>
      </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="优先级队列："><a href="#优先级队列：" class="headerlink" title="优先级队列："></a><strong>优先级队列：</strong></h1><p>按照事先约定的优先级，可以始终高效查找并访问优先级最高数据项的数据结构</p>
<p>维护了数据项的一个偏序关系</p>
<p><strong>操作接口</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">size</span>(); <span class="comment">//报告优先级队列的规模</span></span><br><span class="line"></span><br><span class="line"> <span class="built_in">insert</span>(); <span class="comment">//将指定词条插入优先级队列</span></span><br><span class="line">   </span><br><span class="line">    </span><br><span class="line"> <span class="built_in">getMax</span>();</span><br><span class="line">    </span><br><span class="line"> <span class="built_in">delMax</span>(); <span class="comment">//删除优先级最大的词条</span></span><br></pre></td></tr></table></figure>

<p>应用实例:Huffman编码树，堆</p>
<h3 id="Huffman编码树：略"><a href="#Huffman编码树：略" class="headerlink" title="Huffman编码树：略"></a>Huffman编码树：略</h3><h2 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h2><h3 id="原理："><a href="#原理：" class="headerlink" title="原理："></a>原理：</h3><p>​            主要求解问题：O(1)的算法在n个给定的整数中找最大值, 有限偏序集的极值必然存在，堆用来维护一个偏序关系</p>
<h3 id="性质："><a href="#性质：" class="headerlink" title="性质："></a>性质：</h3><p>​            1.完全二叉树</p>
<p>​            2.保存有序关系. 小根堆:每个结点的值都小于其子结点的值; </p>
<p>​                                        大根堆: 每个结点的值都大于其子结点的值;</p>
<h3 id="物理结构"><a href="#物理结构" class="headerlink" title="物理结构:"></a>物理结构:</h3><p>​        有序列表</p>
<h3 id="主要操作"><a href="#主要操作" class="headerlink" title="主要操作:"></a>主要操作:</h3><p>​                ==上浮操作== —当大根堆的元素变大时，该结点可能会==上浮== —O(log n)</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">up</span><span class="params">(<span class="keyword">int</span> index)</span></span>&#123; <span class="comment">//处于index的元素变大</span></span><br><span class="line">    <span class="keyword">int</span> i=index;</span><br><span class="line">    <span class="keyword">while</span>( i&gt;<span class="number">1</span> &amp;&amp; h[i]&gt;h[i/<span class="number">1</span>])&#123;<span class="comment">//对于大根堆来说，如果子结点大于父结点，一定需要交换</span></span><br><span class="line">        <span class="built_in">swap</span>(h[i],h[i/<span class="number">2</span>]);</span><br><span class="line">        i&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​                ==下沉操作==—当大根堆的元素变小时，该结点可能会==下沉== —-O(log n)</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">down</span><span class="params">(<span class="keyword">int</span> index)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i=index;</span><br><span class="line">    <span class="keyword">while</span>( (<span class="number">2</span>*i&lt;= len &amp;&amp;  h[<span class="number">2</span>*i] &gt; h[i]) ||</span><br><span class="line">         (<span class="number">2</span>*i+<span class="number">1</span>&lt;=len &amp;&amp; h[<span class="number">2</span>*i+<span class="number">1</span>] &gt; h[i])  ) &#123;</span><br><span class="line">        	<span class="keyword">int</span> temp = <span class="number">2</span>*i;         <span class="comment">//temp用于保存 较大的元素的下标</span></span><br><span class="line">       		<span class="keyword">if</span>( h[<span class="number">2</span>*i+<span class="number">1</span>] &gt; h[i] )&#123;</span><br><span class="line">            	temp++; <span class="comment">//temp为2*i+1</span></span><br><span class="line">        	&#125;</span><br><span class="line">    	<span class="built_in">swap</span>(h[index], h[temp]);</span><br><span class="line">        i=temp ;<span class="comment">//判断是否需要继续下沉</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​                 ==插入操作==–O(log n)–在数组最末尾插入元素,再做up操作</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123; <span class="comment">//插入x</span></span><br><span class="line">	len++;</span><br><span class="line">	h[len] = x;</span><br><span class="line">	<span class="built_in">up</span>(len);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​                 ==删除操作==–O(log n)–删除第index个元素，为了不破坏堆的性质，把h[len]移动到index处，堆元素个数减一，再判断做up(index) 还是down(index)</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">delete</span><span class="params">(index )</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> t=h[index];</span><br><span class="line">    h[index]=h[len];</span><br><span class="line">    len--;</span><br><span class="line">    <span class="keyword">if</span>( h[index] &gt;t ) </span><br><span class="line">        <span class="built_in">up</span>(index);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">down</span>(index);</span><br><span class="line">    <span class="keyword">return</span> t;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>过程:   初始建堆</p>
<p>​            方法1：执行n次insert操作,时间复杂度O(n*log n)</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=n;i++)</span><br><span class="line">		<span class="built_in">insert</span>(a[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​            方法2：执行n/2次down操作    </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">()</span></span>&#123;</span><br><span class="line">    len = n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;i++) h[i]=a[i];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=n/<span class="number">2</span>;i&gt;=<span class="number">1</span>;i--) <span class="built_in">down</span>(i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h3><p>初始建堆 O(n),堆排序算法为 O(n log n)</p>
<p>时间复杂度：最好，最坏，平均情况相同</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">HeapSort</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="comment">//初始建堆</span></span><br><span class="line">    <span class="built_in">build</span>();</span><br><span class="line">    <span class="comment">//堆排序</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n<span class="number">-1</span>;i++)&#123;</span><br><span class="line">        <span class="built_in">swap</span>(<span class="number">1</span>,hlen);</span><br><span class="line">        hlen--;</span><br><span class="line">        <span class="built_in">down</span>(<span class="number">1</span>); <span class="comment">//不断删除最大结点</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>(小根堆相反)</p>
<h3 id="STL中堆的使用"><a href="#STL中堆的使用" class="headerlink" title="STL中堆的使用"></a>STL中堆的使用</h3><h4 id="方法1：-lt-queue-gt-中的priority-que"><a href="#方法1：-lt-queue-gt-中的priority-que" class="headerlink" title="方法1：&lt;queue&gt;中的priority_que"></a>方法1：&lt;queue&gt;中的priority_que</h4><h6 id="初始化方式"><a href="#初始化方式" class="headerlink" title="初始化方式"></a>初始化方式</h6><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> Container=std::vector&lt;T&gt;,<span class="keyword">typename</span> Compare=std::less&lt;T&gt; &gt;</span><br><span class="line">class priority_queue</span><br></pre></td></tr></table></figure>

<h6 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a><a target="_blank" rel="noopener" href="http://c.biancheng.net/view/480.html">基本操作</a></h6><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">push</span>(<span class="keyword">const</span> T&amp; obj);<span class="comment">// 将obj的副本放到容器的适当位置，这通常会包含一个排序操作。</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">push</span>(T&amp; obj); <span class="comment">//将obj放到容器的适当位置，这通常会包含一个排序操作。</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">emplace</span>(T constructor a rgs...);</span><br><span class="line"><span class="comment">//通过调用传入参数的构造函数，在序列的适当位置构造一个T对象。为了维持优先顺序，通常需要一个排序操作。</span></span><br><span class="line"><span class="built_in">top</span>();<span class="comment">//：返回优先级队列中第一个元素的引用。</span></span><br><span class="line"><span class="built_in">pop</span>();<span class="comment">//：移除第一个元素。</span></span><br><span class="line"><span class="built_in">size</span>();<span class="comment">//：返回队列中元素的个数。</span></span><br><span class="line"><span class="built_in">empty</span>()<span class="comment">//：如果队列为空的话，返回true。</span></span><br><span class="line"><span class="built_in">swap</span>(priority_queue&lt;T&gt;&amp; other);<span class="comment">//：和参数的元素进行交换，所包含对象的类型必须相同。</span></span><br></pre></td></tr></table></figure>

<h6 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h6><p>1.最基本的使用方法，对于一串数字建堆（默认为大根堆）</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">priority_queue&lt;<span class="keyword">int</span>&gt; heap;</span><br></pre></td></tr></table></figure>

<p>2.自定义</p>
<ul>
<li>使用std::greater 和 std::less</li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/sandalphon4869/article/details/105419706">std::greater和std::less原理解析</a></li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">priority_queue&lt;<span class="keyword">int</span>,vector&lt;<span class="keyword">int</span>&gt;, greater&lt;<span class="keyword">int</span>&gt; &gt; qi2;<span class="comment">//最小堆</span></span><br><span class="line"></span><br><span class="line">priority_queue&lt;<span class="keyword">int</span>,vector&lt;<span class="keyword">int</span>&gt;, less&lt;<span class="keyword">int</span>&gt; &gt;qi3; <span class="comment">//最大堆</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p>使用自定义的cmp类，重载operator</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span></span><br><span class="line">	<span class="keyword">int</span> x;</span><br><span class="line">    <span class="keyword">int</span> y;</span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">   <span class="built_in">Node</span>(<span class="keyword">int</span> a,<span class="keyword">int</span> b,<span class="keyword">int</span> valin):<span class="built_in">x</span>(a),<span class="built_in">y</span>(b),<span class="built_in">val</span>(valin)&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cmp</span>&#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">const</span> Node&amp; a, <span class="keyword">const</span> Node&amp; b)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a.val&lt;b.val;<span class="comment">//大根堆</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">priority_queue&lt;Node,vector&lt;Node&gt;, cmp&gt; heap;<span class="comment">//建堆</span></span><br><span class="line">heap.<span class="built_in">pop</span>();<span class="comment">//出堆</span></span><br><span class="line">heap.<span class="built_in">push</span>();<span class="comment">//入堆</span></span><br><span class="line">heap.<span class="built_in">top</span>(); <span class="comment">//获取堆顶元素</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="方法2：利用vector"><a href="#方法2：利用vector" class="headerlink" title="方法2：利用vector"></a>方法2：利用vector</h4><p>这种法法需要<code>#include&lt;algorithm&gt;</code> <code>#include &lt;functional&gt;</code></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;<span class="keyword">int</span>&gt; a;</span><br><span class="line"><span class="comment">//建堆</span></span><br><span class="line"><span class="built_in">make_heap</span>(a.<span class="built_in">begin</span>(),a.<span class="built_in">end</span>(), less&lt;<span class="keyword">int</span>&gt;() );<span class="comment">//最大堆</span></span><br><span class="line"><span class="built_in">make_heap</span>(a.<span class="built_in">begin</span>(),a.<span class="built_in">end</span>(), greater&lt;<span class="keyword">int</span>&gt;() );<span class="comment">//最小堆</span></span><br><span class="line"><span class="comment">//pop</span></span><br><span class="line"><span class="built_in">pop_heap</span>(a.<span class="built_in">begin</span>(),a.<span class="built_in">end</span>(), less&lt;<span class="keyword">int</span>&gt;() );<span class="comment">//最大值出堆</span></span><br><span class="line"><span class="built_in">pop_heap</span>(a.<span class="built_in">begin</span>(),a.<span class="built_in">end</span>(), less&lt;<span class="keyword">int</span>&gt;() );<span class="comment">//最小值出堆</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//插入元素</span></span><br><span class="line"><span class="built_in">push_heap</span>(a.<span class="built_in">begin</span>(),a.<span class="built_in">end</span>(),cmp);</span><br><span class="line"><span class="comment">//堆排序</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">sort_heap</span>(a.<span class="built_in">begin</span>(),a.<span class="built_in">end</span>(),cmp);</span><br><span class="line"><span class="comment">// push_heap ( begin , end )   将最后一个元素插入堆中（堆自动调整）</span></span><br><span class="line"><span class="comment">// pop_heap ( begin , end )   将第一个元素从堆中删去（堆自动调整），并放到最后</span></span><br><span class="line"><span class="comment">// find ( begin , end , value ) 从begin到end查找value，若找不到，返回end</span></span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/02/12/STL-vector/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/aa.webp">
      <meta itemprop="name" content="Sherry Wang">
      <meta itemprop="description" content="记录点滴成长">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Think World">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/02/12/STL-vector/" class="post-title-link" itemprop="url">vector</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">نُشر في</span>

      <time title="أُنشأ: 2021-02-12 16:12:49" itemprop="dateCreated datePublished" datetime="2021-02-12T16:12:49+08:00">2021-02-12</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">عُدل في</span>
        <time title="عُدل: 2021-07-25 08:53:52" itemprop="dateModified" datetime="2021-07-25T08:53:52+08:00">2021-07-25</time>
      </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="STL-Standard-Template-Library-概念"><a href="#STL-Standard-Template-Library-概念" class="headerlink" title="**STL(Standard Template Library)**概念"></a>**STL(Standard Template Library)**概念</h2><p>​    6大组件： 容器，算法，迭代器，仿函数，适配器，空间配置器</p>
<p>STL的优点：1.不需要额外安装其他软件包</p>
<p>​                    2.实现了数据结构和算法的分离</p>
<p>​                    3.程序员可以不用思考STL具体的实现过程，封装易用</p>
<p>​                    4.高可重用性(模板类，模板函数)</p>
<p>​                    5.高性能</p>
<p>​                    6.高移植性</p>
<p>​                    7.跨平台性</p>
<p>容器：</p>
<p>​    序列式容器：容器的元素的位置是由 进入容器的时机和地点来决定</p>
<p>​    关联式容器：容器已有规则，通常提供键值key作为索引</p>
<p>​    </p>
<h2 id="vector"><a href="#vector" class="headerlink" title="vector"></a>vector</h2><h3 id="动态增长原理"><a href="#动态增长原理" class="headerlink" title="动态增长原理"></a>动态增长原理</h3><p>vector：动态数组,可变数组,单口容器</p>
<p>动态增长原理：当插入新元素的时候，如果空间不足，vector会重新申请更大的一块内存空间，将源空间数据拷贝到新空间，释放旧空间数据，再把新元素插入新申请空间.<strong>注意：一旦引起空间重新配置，指向原vector的所有迭代器都失效了</strong></p>
<p><strong>3个迭代器属性：start,finish,end_of_storage</strong></p>
<p><strong>finish: 指向数组中最后一个元素的下一个位置</strong></p>
<p><img src="STL-vector/2021-02-13_23-09.png" alt="2021-02-13_23-09"></p>
<h3 id="vector常用API"><a href="#vector常用API" class="headerlink" title="vector常用API"></a>vector常用API</h3><h4 id="vector构造函数"><a href="#vector构造函数" class="headerlink" title="vector构造函数"></a>vector构造函数</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;T&gt; V; <span class="comment">//利用模板实现类实现 ，默认构造函数</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>() );  <span class="comment">//v为vector&lt;T&gt;</span></span><br><span class="line"><span class="comment">//将v[begin(), end()] 区间中的元素拷贝给本身</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>(n,elem ); <span class="comment">//构造函数将n个elem拷贝给本身</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//第一个赋值函数</span></span><br><span class="line"><span class="keyword">int</span> arr[] =&#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125;;</span><br><span class="line"><span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">vl</span><span class="params">(arr,arr + <span class="keyword">sizeof</span>(arr)/<span class="keyword">sizeof</span>(<span class="keyword">int</span>) )</span></span>;</span><br></pre></td></tr></table></figure>

<h4 id="其他基本操作"><a href="#其他基本操作" class="headerlink" title="其他基本操作"></a>其他基本操作</h4><h5 id="属性获取"><a href="#属性获取" class="headerlink" title="属性获取"></a>属性获取</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="comment">// 获取数据的开始以及结束位置的指针. 记住这里返回的是迭代器, 也就是vector迭代器就是该类型的指针.</span></span><br><span class="line">    <span class="function">iterator <span class="title">begin</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> start; &#125;</span><br><span class="line">    <span class="function">iterator <span class="title">end</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> finish; &#125;</span><br><span class="line">	<span class="comment">// 获取值</span></span><br><span class="line">	<span class="function">reference <span class="title">front</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> *<span class="built_in">begin</span>(); &#125;</span><br><span class="line">    <span class="function">reference <span class="title">back</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> *(<span class="built_in">end</span>() - <span class="number">1</span>); &#125; </span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取右值</span></span><br><span class="line">	<span class="function">const_iterator <span class="title">begin</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> start; &#125;</span><br><span class="line">    <span class="function">const_iterator <span class="title">end</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> finish; &#125;</span><br><span class="line"></span><br><span class="line">	<span class="function">const_reference <span class="title">front</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> *<span class="built_in">begin</span>(); &#125; <span class="comment">//首元素</span></span><br><span class="line">	<span class="function">const_reference <span class="title">back</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> *(<span class="built_in">end</span>() - <span class="number">1</span>); &#125;<span class="comment">//最后一个元素</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取基本数组信息</span></span><br><span class="line">	<span class="function">size_type <span class="title">size</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> <span class="built_in">size_type</span>(<span class="built_in">end</span>() - <span class="built_in">begin</span>()); &#125;	 <span class="comment">// 数组元素的个数</span></span><br><span class="line">    <span class="function">size_type <span class="title">max_size</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> <span class="built_in">size_type</span>(<span class="number">-1</span>) / <span class="built_in"><span class="keyword">sizeof</span></span>(T); &#125;	<span class="comment">// 最大能存储的元素个数</span></span><br><span class="line">    <span class="function">size_type <span class="title">capacity</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> <span class="built_in">size_type</span>(end_of_storage - <span class="built_in">begin</span>()); &#125;	<span class="comment">// 数组的实际大小</span></span><br></pre></td></tr></table></figure>

<h5 id="元素访问方法"><a href="#元素访问方法" class="headerlink" title="元素访问方法"></a>元素访问方法</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;<span class="keyword">typename</span> T&gt; c;</span><br><span class="line"></span><br><span class="line">c.<span class="built_in">at</span>(index);</span><br><span class="line">c[index]; <span class="comment">//这两种访问方式返回值都是引用，可读可写</span></span><br><span class="line"></span><br><span class="line">c.<span class="built_in">front</span>();<span class="comment">//返回第一个元素</span></span><br><span class="line">c.<span class="built_in">back</span>();<span class="comment">//返回最后一个元素</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h5 id="增删改查"><a href="#增删改查" class="headerlink" title="增删改查"></a>增删改查</h5><ul>
<li><p><strong>push和pop操作都只是对尾部finish进行操作的</strong></p>
</li>
<li><p><code>erase</code>清除是一个<strong>左闭右开的区间</strong>.</p>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">push_back</span><span class="params">(<span class="keyword">const</span> T&amp; x)</span></span>;</span><br><span class="line">vector&lt;T ,Alloc&gt; ::<span class="built_in">insert</span>(iterator position, size_type n, <span class="keyword">const</span> T&amp; x); <span class="comment">//从position开始，插入n个元素，元素的初值是x</span></span><br></pre></td></tr></table></figure>



<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pop_back</span><span class="params">()</span></span>; <span class="comment">//将尾端元素拿掉，并调整大小</span></span><br><span class="line"></span><br><span class="line"><span class="function">iterator <span class="title">erase</span><span class="params">(iterator first,iterator last)</span></span>; <span class="comment">//清除[first,last) 中的所有元素,return first</span></span><br><span class="line">  </span><br><span class="line"><span class="function">iterator <span class="title">erase</span><span class="params">(iterator position)</span></span>; <span class="comment">//清除某个位置上的元素 return position</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123; <span class="built_in">erase</span>(<span class="built_in">begin</span>(), <span class="built_in">end</span>()); &#125;</span><br></pre></td></tr></table></figure>

<h5 id="容器的调整"><a href="#容器的调整" class="headerlink" title="容器的调整"></a>容器的调整</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">reserve</span><span class="params">(size_type n)</span><span class="comment">//修改容器的实际大小</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">resize</span> <span class="params">(size_type new_size)</span></span></span><br></pre></td></tr></table></figure>

<h5 id="vector遍历"><a href="#vector遍历" class="headerlink" title="vector遍历"></a><strong>vector遍历</strong></h5><h6 id="1-使用迭代器"><a href="#1-使用迭代器" class="headerlink" title="1.使用迭代器"></a>1.使用迭代器</h6><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;class T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Iter_for</span><span class="params">(vector&lt;T&gt;&amp; vt)</span></span>&#123;</span><br><span class="line">	T temp;</span><br><span class="line">	vector&lt;T&gt; :: iterator iter;</span><br><span class="line">	<span class="keyword">for</span>(iter=vt.<span class="built_in">begin</span>(); iter!=vt.<span class="built_in">end</span>(); iter++)&#123;</span><br><span class="line">		temp =*iter;</span><br><span class="line">		std::cout&lt;&lt;temp&lt;&lt;std::endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h6 id="2-for-at"><a href="#2-for-at" class="headerlink" title="2.for_at"></a>2.for_at</h6><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;class T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">at_for</span><span class="params">(vector&lt;T&gt;&amp; vt)</span></span>&#123;</span><br><span class="line">	T temp;</span><br><span class="line">    <span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> m=vt.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;m;i++)&#123;</span><br><span class="line">        temp=vt.<span class="built_in">at</span>(i);</span><br><span class="line">        std::cout&lt;&lt;temp&lt;&lt;std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="3-STL-for-each"><a href="#3-STL-for-each" class="headerlink" title="3. STL for_each"></a>3. STL for_each</h6><p><strong>for_each原型</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">template</span> &lt; <span class="keyword">typename</span> InputIterator, <span class="keyword">typename</span> Function &gt;</span><br><span class="line"><span class="function">Function <span class="title">for_each</span><span class="params">(InputIterator beg, InputIterator end, Function f)</span>  </span>&#123;</span><br><span class="line">  <span class="keyword">while</span>(beg != end) </span><br><span class="line">    <span class="built_in">f</span>(*beg++);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span>&amp; temp)</span></span>&#123;</span><br><span class="line">    std::cout&lt;&lt;temp&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> nums[<span class="number">4</span>]=&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125;;</span><br><span class="line">   	vector&lt;<span class="keyword">int</span>&gt; myvt=std::vector&lt;<span class="keyword">int</span>&gt;(nums,nums+<span class="built_in"><span class="keyword">sizeof</span></span>(nums)/<span class="built_in"><span class="keyword">sizeof</span></span>(<span class="keyword">int</span>));</span><br><span class="line">    std::for_each(ptr.<span class="built_in">begin</span>(),ptr.<span class="built_in">end</span>(),print)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="vector高级编程"><a href="#vector高级编程" class="headerlink" title="vector高级编程"></a>vector高级编程</h4><h5 id="元素查找和搜索"><a href="#元素查找和搜索" class="headerlink" title="元素查找和搜索"></a>元素查找和搜索</h5><p>使用STL通用算法find()</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;class InputIterator,class T&gt; <span class="keyword">inline</span></span></span><br><span class="line"><span class="function"> InputIterator <span class="title">find</span><span class="params">(InputIterator first,InputIterator last, <span class="keyword">const</span> T&amp; value)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function">InputIterator <span class="title">find_if</span><span class="params">(InputIterator first,InputIterator last,Predicate predicate)</span></span>;</span><br></pre></td></tr></table></figure>

<h5 id="元素排序"><a href="#元素排序" class="headerlink" title="元素排序"></a>元素排序</h5><p>使用STL通用算法<strong>sort()</strong></p>
<p><strong>sort()底层实现是插入排序优化的快排，时间复杂度是 n*log2(n)</strong></p>
<h6 id="1-跟据元素自身定义的大小关系，进行升序排序"><a href="#1-跟据元素自身定义的大小关系，进行升序排序" class="headerlink" title="1.跟据元素自身定义的大小关系，进行升序排序"></a>1.跟据元素自身定义的大小关系，进行升序排序</h6><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">RandomAccessIterator</span>&gt;</span></span><br><span class="line">   <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(RandomAccessIterator first, RandomAccessIterator)</span></span>;</span><br></pre></td></tr></table></figure>

<p>使用方法</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span>&amp; temp)</span></span>&#123;</span><br><span class="line">    std::cout&lt;&lt; temp&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> nums[] = &#123;<span class="number">34</span>,<span class="number">1</span>,<span class="number">89</span>,<span class="number">0</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">11</span>&#125;;</span><br><span class="line">    std::vector&lt;<span class="keyword">int</span>&gt; ptr = std::vector&lt;<span class="keyword">int</span>&gt;(nums,nums+<span class="built_in"><span class="keyword">sizeof</span></span>(nums)/<span class="built_in"><span class="keyword">sizeof</span></span>(<span class="keyword">int</span>));</span><br><span class="line">    <span class="comment">//遍历方法</span></span><br><span class="line">    std::for_each(ptr.<span class="built_in">begin</span>(),ptr.<span class="built_in">end</span>(),print);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//sort两个参数</span></span><br><span class="line">    std::<span class="built_in">sort</span>(ptr.<span class="built_in">begin</span>(),ptr.<span class="built_in">end</span>());</span><br><span class="line">    std::cout&lt;&lt;std::endl;</span><br><span class="line">    std::for_each(ptr.<span class="built_in">begin</span>(),ptr.<span class="built_in">end</span>(),print);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">34,1,89,0,3,5,11</span></span><br><span class="line"><span class="comment">0,1,3,5,11,34,89</span></span><br><span class="line"><span class="comment">**/</span></span><br></pre></td></tr></table></figure>

<h6 id="2-利用cmp函数定义大小关系，bool-cmp"><a href="#2-利用cmp函数定义大小关系，bool-cmp" class="headerlink" title="2.利用cmp函数定义大小关系，bool cmp{};"></a>2.利用cmp函数定义大小关系，bool cmp{};</h6><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span>&amp; temp)</span></span>&#123;</span><br><span class="line">    std::cout&lt;&lt; temp&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (a&gt;b);<span class="comment">//升序排列</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> nums[] = &#123;<span class="number">34</span>,<span class="number">1</span>,<span class="number">89</span>,<span class="number">0</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">11</span>&#125;;</span><br><span class="line">    std::vector&lt;<span class="keyword">int</span>&gt; ptr = std::vector&lt;<span class="keyword">int</span>&gt;(nums,nums+<span class="built_in"><span class="keyword">sizeof</span></span>(nums)/<span class="built_in"><span class="keyword">sizeof</span></span>(<span class="keyword">int</span>));</span><br><span class="line">    <span class="comment">//遍历方法</span></span><br><span class="line">    std::for_each(ptr.<span class="built_in">begin</span>(),ptr.<span class="built_in">end</span>(),print);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//sort三个参数</span></span><br><span class="line">    std::<span class="built_in">sort</span>(ptr.<span class="built_in">begin</span>(),ptr.<span class="built_in">end</span>(),cmp);</span><br><span class="line">    std::cout&lt;&lt;std::endl;</span><br><span class="line">    std::for_each(ptr.<span class="built_in">begin</span>(),ptr.<span class="built_in">end</span>(),print);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">34 1 89 0 3 5 11 </span></span><br><span class="line"><span class="comment">89 34 11 5 3 1 0 </span></span><br><span class="line"><span class="comment">**/</span></span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/02/06/c-11%E5%88%86%E7%AB%A01/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/aa.webp">
      <meta itemprop="name" content="Sherry Wang">
      <meta itemprop="description" content="记录点滴成长">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Think World">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/02/06/c-11%E5%88%86%E7%AB%A01/" class="post-title-link" itemprop="url">c++11分章1</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">نُشر في</span>

      <time title="أُنشأ: 2021-02-06 20:23:18" itemprop="dateCreated datePublished" datetime="2021-02-06T20:23:18+08:00">2021-02-06</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">عُدل في</span>
        <time title="عُدل: 2021-07-25 09:23:31" itemprop="dateModified" datetime="2021-07-25T09:23:31+08:00">2021-07-25</time>
      </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>主要内容: 引用,指针,数组,动态内存分配</p>
<h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><ul>
<li><p>&lt;类型&gt;&amp;&lt;变量&gt; = &lt;对象或变量&gt;</p>
</li>
<li><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>引用就是变量的另一个别名,对应的变量/对象必须存在</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> x;</span><br><span class="line"><span class="keyword">int</span>&amp; rx = x;</span><br><span class="line"><span class="comment">// int x,&amp;rx = x;</span></span><br></pre></td></tr></table></figure></li>
<li><h3 id="性质"><a href="#性质" class="headerlink" title="性质"></a>性质</h3><p>​    1.通过引用所做的读写操作实际上是作用于原变量上的</p>
<p>​    2.引用必须在声明时,开始初始化</p>
<p>​    3.引用一旦初始化,引用的名字不能再指定给其他变量</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a &#123; <span class="number">0</span> &#125;, b &#123; <span class="number">1</span> &#125;;</span><br><span class="line"><span class="keyword">int</span>&amp; r &#123; a &#125;;  <span class="comment">// 引用变量 r 在声明的同时就要初始化，r是a的别名</span></span><br><span class="line"> </span><br><span class="line">r = <span class="number">42</span>;  <span class="comment">// 相当于 a = 42</span></span><br><span class="line">r = b;   <span class="comment">// 相当于 a = b; 执行后 a 的值是1</span></span><br><span class="line">         <span class="comment">// 此处不是让r变成b的引用</span></span><br><span class="line">         <span class="comment">// 引用r声明并初始化后，r就不能再改为其它变量的引用</span></span><br><span class="line"><span class="keyword">int</span>&amp; r2 = a;  <span class="comment">// 继续给a起别名</span></span><br><span class="line"><span class="keyword">int</span>&amp; r3 = r;  <span class="comment">// 声明引用变量 r3，用r初始化</span></span><br><span class="line">              <span class="comment">// 这个相当于 int&amp; r3 = a; 因为 r 是 a 的别名</span></span><br></pre></td></tr></table></figure></li>
<li><h3 id="指针和引用的差异"><a href="#指针和引用的差异" class="headerlink" title="指针和引用的差异"></a>指针和引用的差异</h3><p><strong>指针和引用的应用场景是函数参数传递</strong></p>
<p>void f(int* pa ,int* pb);  void f(int&amp; pa,int&amp; pb);</p>
<p>从软件设计角度来看，使用引用更好，因为调用方不需要额外传参数时进行取地址运算.</p>
<ul>
<li>存取值的方式<ul>
<li>对指针变量需要使用*来读取相应内存的内容</li>
</ul>
</li>
<li>初始化<ul>
<li>指针没有要求</li>
</ul>
</li>
<li>对象或变量的存在性<ul>
<li>引用有要求</li>
</ul>
</li>
</ul>
</li>
<li><h3 id="const和引用"><a href="#const和引用" class="headerlink" title="const和引用"></a>const和引用</h3><p>**const &lt;类型&gt;&amp;**常用于返回值以及参数传递（保证不能修改相应的变量）</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//变量的引用</span></span><br><span class="line"><span class="keyword">int</span>    val =<span class="number">100</span>;  </span><br><span class="line"><span class="keyword">int</span> &amp; myval1=var;  </span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> &amp; myval2 = var;</span><br><span class="line">myval1 = <span class="number">300</span>;<span class="comment">//合法，可以通过myval2对var进行修改，此时myval2,myval3,var同时被修改</span></span><br><span class="line">myval2 = <span class="number">100</span>;<span class="comment">//非法</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//常量的引用</span></span><br><span class="line"> <span class="keyword">int</span> b=<span class="number">100</span>;  </span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span>&amp; aa=b;<span class="comment">//b的引用，可以选择用const的修饰</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span>&amp; bb=<span class="number">1</span>;<span class="comment">//这里必须用const修饰</span></span><br><span class="line">aa = <span class="number">10</span>；<span class="comment">//非法</span></span><br><span class="line">bb = <span class="number">20</span>;<span class="comment">//非法</span></span><br></pre></td></tr></table></figure></li>
<li><h3 id="引用在参数传递中的使用"><a href="#引用在参数传递中的使用" class="headerlink" title="引用在参数传递中的使用"></a>引用在参数传递中的使用</h3><p>如果在函数中不修改变量，建议使用 const T&amp;</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> var =<span class="number">100</span>;  </span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> cvar  =<span class="number">200</span>;</span><br><span class="line"><span class="comment">/*形参：</span></span><br><span class="line"><span class="comment">void f(int a1,int &amp;a2, const int&amp; a3) </span></span><br><span class="line"><span class="comment">&#123;  &#125;*/</span> </span><br><span class="line"><span class="built_in">f</span>(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>);<span class="comment">//2和a2 不合法</span></span><br><span class="line"><span class="built_in">f</span>(<span class="number">1</span>,var,var);</span><br><span class="line"></span><br><span class="line"><span class="built_in">f</span>(<span class="number">1</span>,cvar,cvar);<span class="comment">//cvar与a2 不合法</span></span><br><span class="line"><span class="built_in">f</span>(<span class="number">1</span>,var,cvar);</span><br><span class="line"></span><br><span class="line"><span class="built_in">f</span>(<span class="number">1</span>,cvar,var);<span class="comment">//cvar和a2 不合法</span></span><br><span class="line"><span class="built_in">f</span>(var,var,var);</span><br><span class="line"><span class="built_in">f</span>(cvar,var,cvar);</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="二维数组的初始化方式"><a href="#二维数组的初始化方式" class="headerlink" title="二维数组的初始化方式"></a>二维数组的初始化方式</h2><h2 id="空指针和动态内存分配"><a href="#空指针和动态内存分配" class="headerlink" title="空指针和动态内存分配"></a>空指针和动态内存分配</h2><p>1.1 0带来的二义性问题</p>
<ul>
<li>C语言中，空指针使用(void *)0来表示, 有时候，用“NULL”来表示空指针(由编译器决定实现方式，一种可能的实现方式是#define NULL 0)</li>
<li>C++03中，空指针使用“0”来表示。0既是一个常量整数，也是一个常量空指针。</li>
<li><strong>C++11中引入保留字“nullptr”作为空指针</strong></li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/02/01/C-%E4%B8%AD%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%80%BB%E7%BB%93/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/aa.webp">
      <meta itemprop="name" content="Sherry Wang">
      <meta itemprop="description" content="记录点滴成长">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Think World">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/02/01/C-%E4%B8%AD%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%80%BB%E7%BB%93/" class="post-title-link" itemprop="url">C++中字符串总结</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">نُشر في</span>

      <time title="أُنشأ: 2021-02-01 14:57:37" itemprop="dateCreated datePublished" datetime="2021-02-01T14:57:37+08:00">2021-02-01</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">عُدل في</span>
        <time title="عُدل: 2021-07-25 08:44:27" itemprop="dateModified" datetime="2021-07-25T08:44:27+08:00">2021-07-25</time>
      </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="c-中string，字符指针，字符数组之间的区别"><a href="#c-中string，字符指针，字符数组之间的区别" class="headerlink" title="c++中string，字符指针，字符数组之间的区别"></a>c++中string，字符指针，字符数组之间的区别</h2><h3 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h3><p>c/c++中设置有常量：在程序运行过程中，其值不能改变的量称为常量</p>
<p>常量分为不同的类型：整型常量(3)，浮点型常量(3.12)，字符型常量(‘a’)，字符串常量(“abc”)</p>
<p>常量一般有两种表现形式：</p>
<ul>
<li>直接常量：直接以值的形式表示的常量称之为直接常量</li>
<li>符号常量：用标识符命名的常量称为符号常量，也就是在直接常量上再取一个名字，方便程序后续维护．习惯用大写字母和下划线来命名<ul>
<li>两种定义方式<ul>
<li>const 类型　符号常量名字＝常量值</li>
<li>#define 符号常量名　常量值</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="字符指针和字符数组的区别"><a href="#字符指针和字符数组的区别" class="headerlink" title="字符指针和字符数组的区别"></a>字符指针和字符数组的区别</h3><p>c/c++中<strong>每个字符串都以字符’/0’作为结尾</strong>．为了节省内存，c/c++把常量字符串放到单独的一个内存区域，当几个指针赋值给相同的常量字符串时，它们实际会指向相同的内存地址．但是用常量内存初始化数组时，情况却有所不同．</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> str1[] = <span class="string">&quot;hello world&quot;</span>;</span><br><span class="line"><span class="keyword">char</span> str2[] = <span class="string">&quot;hello world&quot;</span>;</span><br><span class="line"><span class="comment">//str1!=str2</span></span><br><span class="line"><span class="comment">//c++会为str1,str2分配两个长度为12个字节的空间，并把&quot;hello world&quot;的内容分别复制到数组中．</span></span><br><span class="line"><span class="comment">//str1,str2是两个不同的字符数组，所以初始地址不同</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span>* str3 = <span class="string">&quot;hello world&quot;</span>;</span><br><span class="line"><span class="keyword">char</span>* str4 = <span class="string">&quot;helo world&quot;</span>;</span><br><span class="line"><span class="comment">//str3==str4</span></span><br></pre></td></tr></table></figure>



<p>参考资料</p>
<p>＜剑指offer</p>
<p>&lt; <a target="_blank" rel="noopener" href="http://c.biancheng.net/view/2236.html">http://c.biancheng.net/view/2236.html</a></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2020/11/20/landmark1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/aa.webp">
      <meta itemprop="name" content="Sherry Wang">
      <meta itemprop="description" content="记录点滴成长">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Think World">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2020/11/20/landmark1/" class="post-title-link" itemprop="url">landmark1</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">نُشر في</span>

      <time title="أُنشأ: 2020-11-20 18:31:19" itemprop="dateCreated datePublished" datetime="2020-11-20T18:31:19+08:00">2020-11-20</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">عُدل في</span>
        <time title="عُدل: 2021-07-25 08:46:28" itemprop="dateModified" datetime="2021-07-25T08:46:28+08:00">2021-07-25</time>
      </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>==本篇主要介绍一些　实验过程中用到的一些基础python知识点==</p>
<h2 id="python面向对象"><a href="#python面向对象" class="headerlink" title="python面向对象"></a>python面向对象</h2><h3 id="命名前缀及其含义"><a href="#命名前缀及其含义" class="headerlink" title="命名前缀及其含义"></a>命名前缀及其含义</h3><ul>
<li><strong>前置单下划线</strong><code>_var</code>：命名约定，用来表示该名称仅在内部使用。一般对Python解释器没有特殊含义（通配符导入除外），只能作为对程序员的提示。</li>
<li><strong>后置单下划线</strong><code>var_</code>：命名约定，用于避免与Python关键字发生命名冲突。</li>
<li><strong>前置双下划线</strong><code>__var</code>：在类环境中使用时会触发名称改写，对Python解释器有特殊含义。</li>
<li><strong>前后双下划线</strong><code>__var__</code>：表示由Python语言定义的特殊方法。在自定义的属性中要避免使用这种命名方式。</li>
<li><strong>单下划线</strong><code>_</code>：有时用作临时或无意义变量的名称（“不关心”）。此外还能表示Python REPL会话中上一个表达式的结果。</li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/3/"><i class="fa fa-angle-left" aria-label="الصفحة السابقة"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/3/">3</a><span class="page-number current">4</span><a class="page-number" href="/page/5/">5</a><a class="page-number" href="/page/6/">6</a><a class="extend next" rel="next" href="/page/5/"><i class="fa fa-angle-right" aria-label="الصفحة التالية"></i></a>
  </nav>

</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Sherry Wang</span>
</div>
  <div class="powered-by">تطبيق الموقع <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/" rel="noopener" target="_blank">NexT.Gemini</a>
  </div>

    </div>
  </footer>

  
  <script src="https://cdn.jsdelivr.net/npm/animejs@3.2.1/lib/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/next-boot.js"></script>

  




  





</body>
</html>
